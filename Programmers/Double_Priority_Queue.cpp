// 프로그래머스 heap 문제 중 이중우선순위큐 문제(Lv.3)이며 (https://school.programmers.co.kr/learn/courses/30/lessons/42628)
// 이중 우선순위 큐는
// 1. "I 숫자"가 연산으로 주어지면 큐에 주어진 숫자를 삽입.
// 2. "D 1"이 연산으로 주어지면 큐에서 최대값을 삭제.
// 3. "D -1"이 연산으로 주어지면 큐에서 최솟값을 삭제.
// 4. 큐가 비어있다면 해당 연산은 무시한다.
// 과 같은 연산을 할 수 있는 자료구조를 뜻한다.
// 이때, 이중 우선순위 큐가 할 연산이 담긴 길이 1에서 1,000,000인 1차원 배열이 매개변수로 주어질 때,
// 모든 연산을 처리한 큐가 비어있으면 [0,0], 비어있지않으면 [최대값,최솟값]을
// 출력하도록 해야한다.

// 문제를 해석하면
// 배열에 담긴 연산을 하나씩 처리하고 마지막 연산이 끝났을 때, 큐가 비어있다면 0을 출력하고
// 비어있지 않으면 해당 큐의 최대값과 최솟값을 출력해야한다.
// 처음 문제를 풀 때에 우선순위큐를 2개 선언하여 최대값과 최솟값을 따로 찾을려고 하였지만
// 두 큐에 같은 숫자를 삽입하다보니 큐 하나에서 숫자를 삭제한다면 다른 큐에서도 해당 숫자를 삭제해야하므로
// 불필요한 탐색을 하므로 실행시간이 비정상적으로 늘어났다.
// 그래서 주로 사용할 우선순위 큐(메인큐)를 하나 선언한 다음
// 메인큐를 이용해 삽입을 하고 삭제는 메인큐를 복제한 복제큐를 이용하여 삭제를 한다.
// 삽입은 별다른 제한사항 없이 바로 삽입하면 된다.
// 삭제는 삭제될 큐의 최솟값 바로 위 값까지 복제큐에 복제하면서 메인큐를 비운 다음
// 복제한 큐를 메인큐로 다시 복제하는 방법으로 문제를 풀이하였다.
// 그리고 문제를 푼 이후 다른 사람의 풀이를 보았을 때, multiset을 이용한 문제 풀이를 보았고
// 내가 풀이한 문제풀이보다 훨씬 빠르게 출력하는 것을 보고 아직 부족하다는 것을 느꼈다.
// multiset을 이용한 문제풀이는 multiset에 삽입 후 iterator를 이용한 탐색방법을 이용하였다.


#include <string>
#include <vector>
#include <sstream> // 매개변수가 문자열 배열이므로 문자열을 자르고 형변환을 위한 sstrema 선언
#include <queue> // 우선순위 큐를 이용하기 위한 queue 선언

using namespace std;

// 문자열을 자르고 형변환 함수
pair<char,int> splitStr(string str)
{
	stringstream ss(str);
	char c;
	int n;
	ss >> c;
	ss >> n;
	return {c,n};
}

vector<int> solution(vector<string> operations) {
    vector<int> answer;
	answer.resize(2);
	
	// 메인큐 PQ 선언
	priority_queue<int> PQ;
	
	// 모든 연산을 실행할 때까지 반복
	for(int i = 0;i<operations.size();i++)
	{
		// 문자열로 받은 연산을 사용할 수 있게 분리 및 형변환
		pair<char,int> op = splitStr(operations[i]);
		if(op.first == 'I') // 연산이 삽입이라면
			PQ.push(op.second); // 메인큐에 삽입
		else // 연산이 삭제라면
		{
			if(PQ.empty()) // 메인큐가 비어있다면
				continue; // 다음 연산으로 이동
			
			if(op.second == 1) // 최대값을 삭제해야한다면
				PQ.pop(); // 메인큐 top을 삭제
			else // 최솟값을 삭제해야한다면
			{
				priority_queue<int> temp; // 복제큐를 하나 선언
				// 최솟값을 지워야하기때문에 최솟값 바로 위까지 반복해야한다.
				// 그렇기에 메인큐의 크기가 2가 될 때까지 반복하고 남는 최솟값은 어차피 삭제해야하므로
				// 복제큐에 삽입하지않는다.
				while(PQ.size() >= 2) // 최솟값 바로 위까지 이동하면서
				{
					temp.push(PQ.top()); // 복제큐에 하나씩 삽입하며
					PQ.pop(); // 메인큐 비우기
				}
				PQ = temp; // 삭제해야할 최솟값을 제외한 모든 값을 복제한 복제큐를 다시 메인큐로 바꾼다.
			}
		}
	}
	
	// 최종출력을 위한 변수 선언
	int Max, Min;
	if(PQ.empty()) // 메인큐가 비어있다면
		return {0,0}; // 0,0을 출력한다.
	else // 메인큐가 비어있지않다면
	{
		Max = PQ.top(); // 최대값을 먼저 넣고
		while(PQ.size() != 1) // 최솟값까지
			PQ.pop(); // 값을 지운다.
		Min = PQ.top(); // 그리고 최솟값을 넣는다.
	}
    return {Max,Min};
}