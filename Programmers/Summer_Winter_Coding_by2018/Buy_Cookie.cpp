// Summer/Winter Coding 기출문제 중 하나이며 (Lv.3)
// 문제 : https://school.programmers.co.kr/learn/courses/30/lessons/49995

// 문제를 해석하자면 0~n까지의 수 범위에서 임의의 수 3개 l,m,r을 뽑고
// l에서 m까지의 합과 m+1에서 r까지의 합이 같을 때의 최대값을 리턴하는 문제이다.
// m+1을 기준점으로 잡고 2개의 포인터를 이용해 값을 비교하는 방식으로 문제를 풀이하였다.

// 처음으로 문제를 보고 풀이하였을 때, deque를 이용한 풀이를 하였다.
// 먼저 메인 deque와 첫째가 받은 과자 주머니 순서를 넣은 deque와
// 둘째가 받은 과자 주머니 순서를 넣은 deque 3개를 선언하였다.
// cookie 배열을 메인 deque에 삽입 후에 첫째에 front 삽입하고 제거 후에 두번째 front를 둘째에 삽입한다.
// 첫째와 둘째의 과자 개수가 같다면 answer의 값보다 큰지 확인하고 값을 바꾸고
// 첫째의 과자 개수가 둘째의 과자 개수보다 크다면 deque front 값을 둘째에 주는 방식,
// 첫째의 과자 개수가 둘째의 과자 개수보다 작다고 deque가 비어있지 않다면 둘째의 deque front를 첫째에 주는 방식과
// deque가 비어있다면 첫째 deque front를 제거하는 방식으로 배열을 탐색하였다.
// 하지만 하나의 케이스에서 모든 가능성을 탐색해야 하므로 deque를 이용한 풀이는 적절하지 않았다.
// 그렇기에 하나의 케이스를 뜻하는 기준점(pivot)을 이용하여 2개의 포인터를 움직이며 모든 케이스를 비교하는 방법으로 문제를 풀이하였다.
// 둘째를 기준점으로 잡는 것이 코드를 작성할 때에 편리하므로 둘째를 기준으로 잡고 2개의 첫째 포인터를 둘째 포인터보다 한 칸 앞에
// 위치하도록 선언하고 반복문을 돌리며 포인터를 이동시키며 합산한 값을 비교한다.
// 현재 위치에서 값이 똑같으면 최대값인지 확인하고 값을 변환한다.
// 현재 위치에서 첫째의 과자 개수가 둘째의 과자 개수보다 크다면 둘째 포인터를 오른쪽으로 움직여 과자를 추가한다.
// 반대로 첫째의 과자 개수가 둘째의 과자 개수보다 작다면 첫째 포인터를 왼쪽으로 움직여 과자를 추가한다.
// 이때 첫째 포인터는 -1보다 커야하고 둘째 포인터는 cookie 배열 사이즈보다 작아야한다.
// 기준점을 기준으로 2개의 포인터를 양옆으로 이동하며 값을 비교하는 방식으로 풀이하였기때문에 실행시간은 O(n^2)이다.
// 문제의 최대값은 모든 과자의 개수 절반을 넘길 순 없기때문에
// 첫째의 과자 개수와 둘째의 과자 개수 중 하나라도 넘긴다면 다음 케이스로 이동하는 방식으로
// 불필요한 계산을 줄일 수 있지만 그렇다 하더라도 O(n^2)보다 작게 할 순 없다.
	
#include <vector>

using namespace std;

int solution(vector<int> cookie) {
    int answer = -1; // 최대값을 출력하는 문제이고 문제에서 음수는 나오지 않으므로 -1이 변할 수 없는 최솟값이다.
	if(cookie.size() == 1) // 배열의 크기가 1개라면 문제 조건에 적합한 경우의 수가 없으므로 
		return 0; // 0 리턴
	
	// 매번 합산을 구하기엔 불필요한 계산이 많아지므로 계산한 값을 저장할 수 있는 배열 선언하여 불필요한 계산을 줄인다.
	vector<int> dp(cookie.size()); 
	dp[0] = cookie[0];
	for(int i = 1;i<cookie.size();i++)
		dp[i] = dp[i-1] + cookie[i]; // 합산을 배열에 삽입
	
	// 기준점 m을 0부터 배열 크기까지 반복하며 탐색한다.
	for(int pivot=0;pivot<cookie.size();pivot++)
	{
		// 배열을 N이라 칭할 때, N[i] - Np[i-n] 이 n에서 i 까지의 합산인 것을 이용하며 값을 비교하는데
		// 두 포인터를 움직이며 비교하기엔 코드작성이 어려우므로 2개의 고정된 포인터와 2개의 몇칸 움직였는지 기록하는 변수를 선언하여
		// 포인터를 움직인다.
		int index1 = pivot-1, index2 = pivot; // index1은 첫째, index2는 둘째 고정된 포인터
		int move_index1 = 1, move_index2 = 0; // 2개의 움직이는 포인터 선언
		while(index1-move_index1>=-1 && index2+move_index2<cookie.size()) // 인덱스 안에 움직이며
		{
			int first_sum = dp[index1] - ((index1-move_index1==-1)?0:dp[index1-move_index1]); // 첫째의 과자 개수
			int second_sum = dp[index2+move_index2] - dp[index2-1]; // 둘째의 과자 개수
			if(first_sum == second_sum) // 둘의 값이 같다면
			{
				answer = answer<first_sum?first_sum:answer; // 최대값 비교 후 삽입
				if(index1-move_index1>-1) // 첫째 포인터가 움직일 수 있다면
					move_index1++; // 첫째 포인터를 움직인다.
				else // 못 움직인다면
					move_index2++; // 둘째 포인터를 움직인다.
			}
			else if(first_sum > second_sum) // 첫째의 과자 개수가 둘째의 과자 개수보다 크다면
				move_index2++; // 둘째 포인터를 움직여 둘째의 과자 개수를 추가한다.
			else // 첫째의 과자 개수가 둘째의 과자 개수보다 작다면
				move_index1++; // 첫째 포인터를 움직여 첫째의 과자 개수를 추가한다.
		}
	}
	if(answer == -1) // 조건에 맞는 경우의 수가 없다면 -1이기 때문에
		return 0; // 문제에서 경우의 수가 없다면 0을 리턴하라고 하였으니 0 리턴
    return answer;
}