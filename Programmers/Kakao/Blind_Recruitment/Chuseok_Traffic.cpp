// 2018 Kakao Blind Recruitment 기출문제 7번이며 (프로그래머스 Lv.3) (https://school.programmers.co.kr/learn/courses/30/lessons/17676)
// 이번 추석에 시스템 장애가 없게 하고싶은 개발자 A가 장애 대비용 서버 증설 여부를
// 작년 추석 기간 로그 데이터를 분석한 후 초당 최대 처리량을 확인하고 결정하기로 했다.
// 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1000ms)간
// 처리하는 요청의 최대 개수를 의미한다.

// 로그 데이터의 입력 형식은
// 1. solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며,
//    각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.
// 2. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다.
// 3. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다.
// 4. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 "2016년 9월 15일 오전 3시 10분 33.010초"부터
//    "2016년 9월 15일 오전 3시 10분 33.020초"까지 "0.011초" 동안 처리된 요청을 의미한다.
//    (처리시간은 시작시간과 끝시간을 포함)
// 5. 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.
// 6. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.
// 이고
// 출력 방식은
// solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.
// 이다.

// 문제 해석을 하자면
// 매개변수로 받은 로그 데이터를 나열하고 탐색하여 전체 구간에서의 초당 최대 처리량을 구해 리턴하는 문제이다.
// 먼저 시간을 이용한 문제이기 때문에 문제에서 주어진 시간 단위 중 최소 단위를 쓰는 것이 구현하는데 편리함을 준다.
// 그렇기에 이 문제에서의 시간의 최소 단위는 ms이므로 hh:mm:ss.sss으로 주어진 시간을 ms로 통일한 후에 코드를 작성하는 것이 좋다.
// 로그 데이터를 어떻게 나열할지와 나열한 로그 데이터를 어떻게 탐색할지, 기준을 어떻게 잡느냐에 따라 문제의 실행시간이 달라진다.

// 문제 풀이
// 두 가지 풀이방식이 있는데 슬라이딩 윈도우 알고리즘과 로그 데이터들을 시작과 끝 지점을 포함하여 정렬 후 탐색하는 방법이 있다.
// 현재는 후자를 택한 방법으로 풀이하였지만, 슬라이딩 윈도우를 이용한 풀이 또한 할 것이다.
// 먼저 O(n^2)인 슬라이딩 윈도우 알고리즘은 첫 로그 데이터부터 마지막 로그 데이터까지 1ms씩 증가하면서 전부 탐색하려고 하면
// 연산시간이 매우 크기 때문에 문제가 된다.
// 또 각 로그 데이터의 시작과 끝을 슬라이딩 윈도우로 연산해도 이전보단 낫지만, 결코 낮은 수치는 아니기때문에 문제가 된다.
// 하지만 로그 데이터의 요청량이 변하는 구간은 각 로그 데이터의 시작과 끝이라는 것을 알 수 있다.
// 그렇기에 로그 데이터를 기준으로 슬라이딩 윈도우로 연산을 실행하면 실행시간이 O(n^2)가 된다는 것을 알 수 있다.
// 두번째로 로그 데이터들을 시작과 끝 지점을 포함하여 정렬 후 탐색하는 방법이 있다.
// 자료구조를 선언하여 ms로 변환한 시간 값과 로그 데이터의 요청 시작 시각인지 요청 종료 시각인지 구별할 수 있는 변수를 선언하고
// 1차원 배열에 삽입 후 정렬을 한다. 그리고 현재 처리하는 로그 데이터의 개수를 담을 수 있는 정수형 변수를 선언한다.
// 이때, 정렬할 때에 시간 값을 기준으로 오름차순으로 정렬하되 같은 시간 값인 경우엔 시작 시간이 더 앞에 오도록 한다.
// 정렬 후에 배열 기점에서 종점까지 탐색하며 현재 index가 요청 시작 시각이면 위에 선언한 정수형 변수에 1을 더하고
// 요청 종료 시각이면 1을 빼는 형식으로 탐색하고 index가 올라갈 때마다 리턴 값과 정수형 변수 값 중 큰 것을 기록한다.

// 문제를 처음 봤을 때,deque을 이용하여 슬라이딩 윈도우를 변형한 방법으로 문제 풀이를 시도하였다.
// 먼저 요청 시작 시각을 기준으로 오름차순으로 정렬 후에 deque를 이용하여 로그 데이터를 하나씩 넣어가며
// front의 로그 데이터의 처리시각과 겹치는지 확인하고 겹치지 않는다면 front를 제거 후에
// 새로운 front와 겹치는지 확인하는 방법으로 문제를 풀이하였다.
// 하지만 front를 제거를 하다 보니 이전 front일 때 겹치는 예외때문에 풀이를 멈추고 새로운 풀이로 풀어나가는 도중에
// n^2가 아니고 더 빠른 방법이 있을 것을 추측하고 다른 사람의 풀이방식을 참고하여 이 풀이로 풀이하였다.


#include <string>
#include <vector>
#include <sstream> // 문자열을 정수형으로 변환해야하므로 sstream 헤더 선언
#include <algorithm> // 정렬알고리즘을 사용해야하므로 algorithm 헤더 선언

using namespace std;

enum {Start,End}; // 해당 시각이 요청 시작 시각인지 요청 종료 시각인지 확인하기 위한 자료구조 선언

// 정렬할 때에 사용할 비교함수
bool equl(pair<int,int> t1, pair<int,int> t2)
{
	if(t1.first == t2.first) // 동일 시각이면
		return t1.second < t2.second; // 요청 시작 시각이 앞으로 간다.
	else
		return t1.first < t2.first;
}

vector<pair<int,int>> strSplit(vector<string> v)
{
	vector<pair<int,int>> ret; // 리턴할 배열 선언
	for(string str : v) // 모든 로그 데이터를 탐색한다.
	{
		stringstream ss(str); // 문자열로 된 로그 데이터를 stringstream에 삽입
		pair<int,int> record; // 배열에 들어갈 자료구조 선언
		string time; // 시간값을 담을 문자열 선언
		ss >> time >> time; // 첫번째 블럭은 불필요한 문자열이기 때문에 두번 입력받아 두번째 블럭으로 덮어쓴다.
		int ms = stoi(time.substr(0,2))*3600000 + stoi(time.substr(3,2))*60000 + stod(time.substr(6,6))*1000;
		// double이나 float로 선언하면 값을 비교할 때에 정확하지 않기 때문에 1000을 곱해 정수형으로 변환한다.
		
		ss >> time; // 처리 시각을 입력받는다.
		int work = stod(time.substr(0,5))*1000; // 처리 시각 또한 소숫점이 포함되므로 1000을 곱해 정수형으로 변환한다.
		
		record.first = ms - work + 1; // 요청 시작 시각
		record.second = Start; // 요청 시작 시각이기 때문에 Start 삽입
		ret.push_back(record); // 배열에 삽입한다.
		
		record.first = ms + 999; // 요청 종료 시각을 기준으로 1초를 더 탐색해야하므로 999를 삽입한다. (시작 시각에 1을 더했기 때문에 999)
		record.second = End; // 요청 종료 시각이기 때문에 End 삽입
		ret.push_back(record); // 배열에 삽입한다.
	}
	return ret;
}

int solution(vector<string> lines) {
    int answer = 0;
	vector<pair<int,int>> times = strSplit(lines);
	
	sort(times.begin(),times.end(),equl); // equl 함수에 따라 정렬
	
	int cur_working = 0; // 현재 처리하는 로그 데이터의 수
	for(int i = 0;i<times.size();i++) // 나열한 타임 테이블을 모두 탐색한다.
	{
		if(times[i].second == Start) // 해당 시각이 요청 시작 시각이라면
			cur_working++; // 처리하는 로그 데이터 수에 1을 더한다.
		else // 해당 시각이 요청 종료 시각이라면
			cur_working--; // 처리하는 로그 데이터 수에 1을 뺀다.
		
		answer = max(answer,cur_working); // 매 탐색마다 최대값을 갱신한다.
	}
    return answer;
}