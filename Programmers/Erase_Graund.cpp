// 2022 KAKAO BLIND RECRUITMENT 기출문제 7번 문제이며 (프로그레머스 Lv.3) (https://school.programmers.co.kr/learn/courses/30/lessons/92345)
// 두 플레이어 A, B가 게임을 하고 있을 때, 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하는 문제이다.
// 게임 방식은
// 1. 1*1 정사각 격자로 이루어진 보드 위에서 시작하며 보드에는 발판이 있는 부분과 없는 부분이 있다.
// 2. 발판이 있는 곳에서만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있다.
// 3. 캐릭터는 발판이 있는 곳으로만 움직일 수 있으며, 보드 밖으로 이동할 수 없다.
// 4. 밟고 있던 발판은 캐릭터가 다른 발판으로 이동할 때 사라진다.
// 5. 캐릭터는 상하좌우 4방향으로만 움직인다.
// 으로 이루어져있으며 승리조건은
// 1. 움직일 차례일 때 상하좌우에 발판이 없거나 보드판 밖으로 이동해야할 때
// 2. 두 캐릭터가 같은 발판에 서있을 때, 상대 플레이어가 다른 발판으로 이동하여 자신 캐릭터의 발판이 사라질 때
// 패배한다.
// 해당 게임은 A가 먼저 움직이며
// 양 플레이어는 최적의 플레이를 한다.
// 이때 최적의 플레이란 자신이 이길 수 있으면 최대한 빨리 이기는 플레이를
// 자신이 질것 같으면 최대한 늦게 지는 플레이를 뜻한다.
// '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 뜻하며
// '질 수 밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 지는 플레이어를 뜻한다.
// 최대한 늦게 지는 플레이는 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미한다.
// 이런 조건으로 이루어지는 게임에서 양 플레이어가 최적의 플레이를 했을 때,
// 두 캐릭터의 움직인 횟수의 합을 출력하는 문제이다.
// 매개변수로 보드 초기 상태를 나타내는 2차원 배열과
// A 플레이어의 캐릭터의 초기 위치를 나타내는 1차원 배열과
// B 플레이어의 캐릭터의 초기 위치를 나타내는 1차원 배열이 주어진다.

// 먼저 문제 해석을 하자면
// 이길 수 있는 플레이어는 최대한 빨리, 질 수 밖에 없는 플레이어는 최대한 늦게
// 게임을 끝내는 방향으로 게임을 해야한다.
// 하지만 문제 매개변수로는 누가 이긴다는 매개변수는 없다.
// 그렇기에 문제를 처음보면 매개변수로 주어진 좌표값을 통해 무조권 이기는 플레이어를 찾고
// 찾은 플레이어를 통해 탐색을 하여 문제의 답을 출력하는 것처럼 보일 수도 있다.
// 하지만 문제에 '실수를 하지 않으면'이라는 문구를 통해
// '실수를 해도 무조권 이기는 플레이어는 없다'를 유추할 수 있으므로
// 양 플레이어의 플레이를 모두 탐색하여 최적의 답을 출력하는 방식으로 해야한다.
// 그렇기에 모든 경우의 수를 탐색해야하므로 완전탐색을 이용하였고
// 양 플레이어가 최적의 플레이를 해야하므로
// DFS를 이용한 minimax 알고리즘을 사용하였다.
// minimax 알고리즘은 주로 체스, 틱택톡, 오목과 같은 턴을 주고 받는 게임에서 최적의 플레이를 계산하는 알고리즘이다.
// 이때 minimax 알고리즘을 따로 배우지 않아서 문제 풀이할 때 많은 시행착오를 겪었다.
// minimax 알고리즘을 찾아보기 전에도 DFS를 이용했지만
// top-down 방식으로 첫 수부터 여러갈래로 나뉘는 방식으로 탐색을 하였지만
// 문제가 해결이 되지않아 새로운 알고리즘을 찾아보았고 minimax 알고리즘을 알게되었다.
// minimax 알고리즘은 bottom-up DFS를 이용하여 리프분기로 이동 후
// 천천히 올라오면서 자신의 턴일 땐 이득을 보는 수를 선택하고
// 상대의 턴일 땐 손해를 보는 수를 선택을 하여 루트분기까지 왔을 때, 최적의 수를 출력하는 알고리즘이다.
// 하지만 문제에 적용 하기엔 승자가 정해진 상태에서 이루어지는 알고리즘이기 때문에,
// 승자는 이득이 보는 수를, 패자는 손해를 보는 수를 선택하므로
// 문제에 맞게 해당 알고리즘을 수정을 해야한다.
// 문제는 서로 이기려고 하기때문에 리프분기까지 내려간 다음 루트분기까지 올라가며
// 해당 분기에서 이전 분기들의 승패를 확인 후 최선의 플레이를 선택하는 방식으로 조금의 변형이 필요하다.


#include <string>
#include <vector>
#include <algorithm> // min,max 함수를 이용하기 위한 헤더 선언

using namespace std;

// 상하좌우로 이동하기 위한 배열 선언
vector<int> dr = {-1,0,1,0};
vector<int> dc = {0,-1,0,1};

//minimax 알고리즘
int PlayGame(vector<vector<int>> board, vector<int> cur, vector<int> next)
{
	int Rturn = 0; // 상위분기로 출력하기 위한 변수
	if(!board[cur[0]][cur[1]]) // 내 캐릭터가 위치한 발판이 없다면 패배하기때문에
		return 0; // 리프분기이므로 0 리턴
	else
	{
		// 상하좌우로 이동하기 위한 반복문
		for(int i = 0;i<dr.size();i++)
		{
			int R = cur[0] + dr[i];
			int C = cur[1] + dc[i];
			// 보드 밖으로 이동하려고 하면
			if(R<0 || R>=board.size() || C<0 || C>=board[0].size())
				continue; // 다른 방향으로 이동
			if(board[R][C] == 0) // 이동할려는 방향에 발판이 없다면
				continue; // 다른 방향으로 이동
			vector<vector<int>> Newboard = board; // 원본을 보존하기 위한 복제본 초기화
			Newboard[cur[0]][cur[1]] = 0; // 이동하기때문에 현재 발판을 없앤다.
			// 이동할 방향으로 이동 후 최적의 플레이를 출력받았을 때 1을 더하여 수를 둔 것을 표현
			int turn = PlayGame(Newboard,next,{R,C}) + 1;
			
			// 모두 패배한 상태에서 이번 수가 승리했다면
			if(Rturn%2==0 && turn%2==1)
				Rturn = turn; // 현재 수를 출력값으로 대입
			// 모두 패배한 상태에서 이번 수도 패배했다면
			else if(Rturn%2==0 && turn%2==0)
				Rturn = max(Rturn,turn); // 패배한 상태에서 최적의 플레이는 오래동안 버텨야하므로 최대값 비교
			// 승리한 상태가 있는 상황에서 또 승리했다면
			else if(Rturn%2==1 && turn%2==1)
				Rturn = min(Rturn,turn); // 승리한 상태에서 최적의 플레이는 빨리 끝내야하므로 최소값 비교
		}
	}
	return Rturn; // 상위분기로 출력
}


int solution(vector<vector<int>> board, vector<int> aloc, vector<int> bloc) {
    int answer = -1;
	answer = PlayGame(board,aloc,bloc);
    return answer;
}