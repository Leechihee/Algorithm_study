// 프로그래머스 BFS/DFS 문제 중 아이템 줍기(Lv. 3)이며 (https://school.programmers.co.kr/learn/courses/30/lessons/87694)
// 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 할 때,
// 캐릭터가 아이템을 줍기 위해 이동해야 하는 최단거리를 출력해야 한다.
// 다각형 모양 지형은 x축과 y축이 평행한 직사각형이 겹쳐진 상태로 표현하며,
// 이동 경로는 다각형 모양의 가장 바깥쪽 테두리이다.
// 만약 여러 직사각형이 겹쳐 만들어진 지형에서 중앙이 비어있어도 가장 바깥쪽 테두리가 이동 경로이며,
// 서로 다른 두 직사각형이 꼭짓점에서 만나거나 변이 겹치는 경우는 없다.
// 그리고 지형이 2개 이상으로 생기는 경우 또한 없다.
// 즉 지형은 무조건 1개이다.
// 마지막으로 한 직사각형이 다른 직사각형을 완전히 포함하는 경우 또한 없다.
// 문제의 제한사항으로는
// 1. rectangle의 행 길이는 1이상 4이하이다.
// 2. rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태이다.
//   2-1. 직사각형을 나타내는 모든 좌표값은 1이상 50이하인 자연수이다.
//   2-2. 서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없다.
//   2-3. 문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다.
// 3. charcterX, charcterY는 1 이상 50 이하인 자연수이다.
//   3-1. 지형을 나타내는 다각형 테두리 위의 한 점이 주어진다.
// 4. itemX, itemY는 1 이상 50 이하인 자연수이다.
//   4-1. 지형을 나타내는 다각형 테두리 위의 한 점이 주어진다.
// 5. 캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다.
// 가 주어진다.

// 문제를 해석하자면
// 주어지는 여러 개의 직사각형 좌표를 이용하여 다각형 모양의 지형을 만든 후
// 가장 바깥쪽 테두리를 이동 경로로 한 목표 지점까지의 최단거리를 구하는 문제이다.
// 최단 거리를 구하는 문제이므로 BFS/DFS를 이용해야 한다.
// 문제 요구사항 자체는 어렵진 않았지만, 구현은 세세한 부분을 신경을 써야 한다.
// 처음에 다각형 모양의 지형을 구현하는 함수를 좌표평면 위의 1칸을 길이를 1로 생각하고 구현을 하였지만
// 테스트 케이스에서 마주 보는 한 쌍의 변의 길이가 2인 경우엔
// 1칸씩 이동하는 BFS/DFS를 이용하기에는 정확한 값이 출력하지 않았기에
// 좌표평면 위의 1칸의 길이를 0.5로 생각하고 다각형 모양의 지형을 만들어야 하며,
// 1칸의 길이가 0.5이므로 정답으로 출력할 때에 2를 나누어 출력해야 한다.

#include <vector>

using namespace std;

// 재귀함수 매개변수를 줄이기 위한 전역변수&배열 선언
vector<vector<int>> rect(102,vector<int>(102,0)); // 다각형 모양 지형을 저장하기 위한 2차원 배열 선언
vector<vector<bool>> visit(102,vector<bool>(102,false)); // DFS를 하기 위한 방문 배열 선언
int endX; // 도착지점 X좌표값 선언
int endY; // 도착지점 Y좌표값 선언
int answer = 10e8; // 최단거리를 출력해야하므로 출력값에서 넘을 수 없는 값으로 선언

// 상하좌우로 이동하기 위한 배열 선언
vector<int> dx = {-1,1,0,0};
vector<int> dy = {0,0,-1,1};


//다각형 모양 지형을 구현하기 위한 함수
void make_rect(vector<vector<int>> R)
{
	// 모든 직사각형을 구현할 때까지 반복
	for(vector<int> v : R)
	{
		// 가로선부터 구현
		for(int x = 0;x<=(v[2]-v[0])*2;x++) // 좌측 X좌표부터 우측 X좌표까지
		{
			if(rect[v[0]*2+x][v[1]*2] != 2) // 해당 칸이 다각형 모양 내부가 아니라면
				rect[v[0]*2+x][v[1]*2] = 1; // 선을 긋는다
			if(rect[v[2]*2-x][v[3]*2] != 2) // 해당 칸이 다각형 모양 내부가 아니라면
				rect[v[2]*2-x][v[3]*2] = 1; // 선을 긋는다
		}
		
		// 가로선 구현 후 세로선 구현
		for(int y = 0;y<=(v[3]-v[1])*2;y++)
		{
			if(rect[v[0]*2][v[1]*2+y] != 2) // 해당 칸이 다각형 모양 내부가 아니라면
				rect[v[0]*2][v[1]*2+y] = 1; // 선을 긋는다
			if(rect[v[2]*2][v[3]*2-y] != 2) // 해당 칸이 다각형 모양 내부가 아니라면
				rect[v[2]*2][v[3]*2-y] = 1; // 선을 긋는다
		}
		
		//가로선, 세로선 구현 후 직사각형 내부를 매꾼다.
		for(int x = v[0]*2+1;x<v[2]*2;x++)
		{
			for(int y = v[1]*2+1;y<v[3]*2;y++)
				rect[x][y] = 2;
		}
	}
}

// 최솟값 출력을 위한 min함수
int min(int n1, int n2)
{
	return (n1<n2)?n1:n2;
}

// 최단거리를 구하기 위한 DFS 함수
void DFS(int curX, int curY, int MC)
{
	// 현재 캐릭터 위치가 아이템이 있는 위치라면
	if(curX == endX && curY == endY)
	{
		answer = min(answer,MC/2); // 값을 비교 후
		return; // 탐색을 종료한다.
	}
	// 현재 캐릭터 위치가 아이템이 있는 위치가 아니라면
	
	visit[curX][curY] = true; // 현재 위치는 방문했기 때문에 true 대입
	
	// 상하좌우로 이동하기 위한 반복문
	for(int i = 0;i<dx.size();i++)
	{
		int X = curX + dx[i];
		int Y = curY + dy[i];
		if(X<0 || X>=102 || Y<0 || Y>=102) // 좌표평면을 벗어나는 이동이라면
			continue; // 다른 이동으로 이동
		// 이미 방문한 길이거나 길이 없거나 도형 내부로 이동한다면
		if(visit[X][Y] == true || rect[X][Y] == 0 || rect[X][Y] == 2)
			continue; // 다른 이동으로 이동
		DFS(X,Y,MC+1); // 이동할 좌표로 이동 후 움직인 횟수 1 추가
	}
}

int solution(vector<vector<int>> rectangle, int characterX, int characterY, int itemX, int itemY) {
	make_rect(rectangle);
	endX = itemX*2;
	endY = itemY*2;
	DFS(characterX*2,characterY*2,0);
    return answer;
}