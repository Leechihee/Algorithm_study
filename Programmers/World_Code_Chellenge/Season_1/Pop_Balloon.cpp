// 월드 코드 챌린지 시즌1 문제 중 풍선 터트리기(프로그래머스 기준 Lv.3)이며 (https://school.programmers.co.kr/learn/courses/30/lessons/68646)
// 일렬로 나열된 서로 다른 숫자가 적힌 n개의 풍선을
// 다음과 같은 과정을 반복하며 풍선이 1개 남을 때까지 계속 터트려야한다.
// 1. 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트린다.
// 2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킨다.
// 라는 과정을 거쳐야하며 조건사항으론
// 1. 임의로 선택한 인접한 두 풍선 중 숫자가 더 큰 풍선을 터트린다.
// 2. 과정을 반복하고 있을 때, 숫자가 작은 풍선을 터트리는 과정은 최대 1번만 가능하다.
// 가 주어지고 문제의 제한사항으론
// 1. a의 길이는 1 이상 1,000,000 이하입니다.
//   1-1. a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다.
//   1-2. a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
//   1-3. a의 모든 수는 서로 다릅니다.
// 가 주어진다.
// 이때, 주어진 조건에 따라 풍선이 1개 남을 때까지 과정을 반복 후 최후 풍선에 적힌 숫자들을 출력하는 문제이다.
// 매개변수로는 일렬로 나열된 풍선들의 번호가 담긴 1차원 배열이 주어진다.

// 문제를 해석하자면
// 문제 과정의 조건 중 2번 조건이 없다면 최후에 남는 풍선은 1차원 배열에서의 최솟값인 경우만 남는다.
// 2번 조건에 의해서 최솟값만 남는 것이 아닌 다른 경우의 풍선이 남는 것이다.
// 이것을 통해서 키포인트를 찾을 수 있다.
// 과정 2번 조건을 이용하여 마지막 과정 때 본인과 최솟값만 남길 수 있다면
// 최솟값이 적힌 풍선을 터트리면서 남는 다른 하나의 풍선은 최후에 남는 풍선이 된다.
// 최솟값이 적힌 풍선은 모든 풍선을 터트릴 수 있으므로
// 기준이 되는 풍선 좌우로 탐색했을 때 터트리지 못하는 풍선이 있다면
// 그 풍선은 최후까지 남지 못하는 풍선인것을 이용하여 문제를 풀이해야한다.
// 즉, 비교하는 숫자가 양 측의 최솟값보다 작다면 최후까지 남을 수 없는 풍선이고
// 최솟값 2개를 비교 했을 때 1개 이상은 커야한다.
// 그러므로 1차원 배열의 양 끝부분부터 시작하여 서로 만날 때까지 좌, 우 최솟값을 계속 최신화를 한다.
// 이때, 좌, 우 최솟값이 최신화가 된다면 최신화가 되는 풍선은 최후까지 있을 수 있는 풍선이고
// 양 끝의 최솟값보다 큰 값이라면 마지막에 올 최솟값을 터트릴 수 없으므로 최후까지 남을 수 없는 풍선이다.

// 처음 문제를 봤을 때는 DFS를 이용하여 분기별로 탐색하여 리프분기일 때 풍선에 적힌 숫자를
// set에 삽입하여 중복되는 경우의 수를 제외하는 방식으로 풀이하였다.
// 하지만 문제 제한사항으로 1차원 배열의 크기는 1,000,000가 주어지는데
// DFS의 시간복잡도는 O(n^2)이므로 해당 문제에 맞지않다라고 판단하여 다른 방식으로 풀이하였다.
// DFS가 아닌 다른 방법으로 풀이하였을 땐
// 배열에 있는 최솟값을 이용하여 풀이하려고 하였다.
// 해석과 동일한 내용이지만 하나의 최솟값을 이동하며 숫자를 지우며 탐색하는 방식으로 풀이하였지만
// 정확도 문제와 시간복잡도 또한 문제가 되어 새로운 풀이방식인 양 끝부터 탐색하는 방식으로 풀이하였다.

#include <string>
#include <vector>
#include <deque> // 양 끝을 탐색해야하므로 deque 헤더선언

using namespace std;

int solution(vector<int> a) {
	vector<int> result; // 남을 수 있는 풍선을 담기 위한 배열선언
	deque<int> DQ; // 탐색을 하기 위한 덱 선언
	
	// 덱에 풍선들을 삽입
	for(int n : a)
		DQ.push_back(n);
	
	// 양 쪽 최솟값을 저장 하기 위한 변수 초기화
	int left_min = 1000000001; // 제한 사항으로 숫자의 최댓값은 1,000,000이므로 1,000,001으로 초기화
	int right_min = 1000000001;
	
	// 양 쪽 최솟값이 만나야하므로 덱이 빌 때까지 반복
	while(!DQ.empty())
	{
		if(left_min > right_min) // 좌측 최솟값이 우측 최솟값보다 크다면 먼저 비교한다.
		{
			if(left_min > DQ.front()) // 좌측 최솟값이 비교하는 풍선의 값보다 크다면 비교하는 풍선이 지금까지의 좌측에서부터 터트려왔던 모든 풍선을 터트릴 수 있기때문에
			{
				left_min = DQ.front(); // 좌측 최솟값을 최신화한 다음
				result.push_back(left_min); // 결과값 배열에 삽입
			}
			DQ.pop_front(); // 다음 풍선을 비교하는 풍선으로 선택 하기 위해 죄측 부분 제거
		}
		else // 우측 최솟값이 좌측 최솟값보다 크다면
		{
			if(right_min > DQ.back()) // 우측 최솟값이 비교하는 풍선의 값보다 크다면 비교하는 풍선이 지금까지의 우측에서부터 터트려왔던 모든 풍선을 터트릴 수 있기때문에
			{
				right_min = DQ.back(); // 우측 최솟값을 최신화한 다음
				result.push_back(right_min); // 결과값 배열에 삽입
			}
			DQ.pop_back(); // 다음 풍선을 비교하는 풍선으로 선택 하기 위해 우측 부분 제거
		}
	}
    return result.size(); // 풍선의 개수를 출력하기때문에 size() 메서드를 리턴한다.
}