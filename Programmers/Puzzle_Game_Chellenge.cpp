// 2024 PCCP 기출문제 2번(Lv.2) 퍼즐 게임 챌린지이며
// 주어진 퍼즐을 제한시간 내에 모두 풀어야하는 퍼즐 게임을 하고 있으며
// 매개변수로 퍼즐의 난이도가 담긴 배열과 퍼즐을 푸는데 사용하는 시간이 담긴 배열, 제한시간이 주어지며
// 매개변수를 이용하여 제한시간 내에 모든 퍼즐을 해결할 수 있는 숙련도의 최솟값을 리턴하는 문제이다.
// 퍼즐 게임의 진행 방식은
// (현재 퍼즐 난이도를 Cur_D, 현재 퍼즐의 소요시간을 Cur_T, 직전 퍼즐의 소요시간은 Prev_T, 숙련도를 LV로 표기)
// 1. Cur_D <= LV이라면 퍼즐을 틀리지 않고 Cur_T만큼 사용하여 퍼즐을 해결
// 2. Cur_D > LV이라면 퍼즐을 Cur_D - LV만큼 틀린다.
//    퍼즐을 틀릴때마다 Cur_T를 사용하여 다시 풀이한다.
//    풀고 있는 퍼즐을 틀릴때마다 이전 퍼즐을 다시 풀어야한다. 따라서 Prev_T만큼 시간을 사용해야한다.(단, 이전 퍼즐을 다시 풀땐 난이도와 상관없이 정답이다)
//    Cur_D - LV만큼 틀린 이후 다시 퍼즐을 풀이하면 Cur_T만큼 사용하여 퍼즐을 해결한다.
// 으로 진행된다.
// 문제의 제한사항으로
// 1. 1 ≤ diffs의 길이 = times의 길이 = n ≤ 300,000
//   1-1.diffs[i]는 i번째 퍼즐의 난이도, times[i]는 i번째 퍼즐의 소요 시간입니다.
//   1-2. diffs[0] = 1
//   1-3. 1 ≤ diffs[i] ≤ 100,000
//   1-4. 1 ≤ times[i] ≤ 10,000
// 2. 1 ≤ limit ≤ 10e15
//   2-1. 제한 시간 내에 퍼즐을 모두 해결할 수 있는 경우만 입력으로 주어집니다.
// 가 주어진다.
// 먼저 완전탐색을 이용하기엔 diffs의 최대크기가 300000이므로 적절하지 않다.
// 때문에 이진탐색(이분탐색)을 사용하여 탐색 시간을 획기적으로 줄이는 방식으로 풀이하였다.

#include <vector>

using namespace std;

int solution(vector<int> diffs, vector<int> times, long long limit) {
    long long answer = 1000001; // 제한사항으로 매개변수 최대값은 100,000이므로 넘을 수 없는 최댓값 100,001으로 대입
	long long start = 1, end = 100000; // 제한사항으로 문제의 최소, 최대 난이도는 각각 1, 100,000이므로 이진탐색 시작점, 끝점으로 대입
	while(start <= end) // 이진탐색 종료문
	{
		long long centor = (start+end)/2; // 범위를 이진으로 나누기위한 중앙값과 동시에 현재 숙련도
		long long seccT = 0; // 현재 숙련도로 문제를 모두 풀이하는데 사용하는 시간
		int prev_T = 0; // 이전 문제를 풀이하는데 사용하는 시간
		for(int i = 0;i<diffs.size();i++) // 문제만큼 반복
		{
			if(diffs[i] > centor) // 숙련도가 문제의 난이도보다 낮다면
			{
				long long fail_count = diffs[i] - centor; // 차이만큼 틀리고
				seccT += (prev_T + times[i]) * fail_count + times[i];
				// 틀린 횟수만큼 풀이 후 정답 풀이하는데 걸리는 시간을 더한다.
			}
			else // 숙련도가 문제의 난이도보다 크다면
				seccT += times[i]; // 틀리지않고 풀이하기때문에 바로 정답 풀이하는 시간을 더한다.
			prev_T = times[i]; // 다음문제로 넘어가기때문에 현재 풀이시간을 대입.
		}
		
		if(seccT > limit) // 성공시간이 제한시간보다 크다면 숙련도가 부족하므로
			start = centor+1; // 시작점을 중앙값 다음으로 지정
		else // 성공시간이 제한시간보다 작다면 숙련도가 널널하므로
			end = centor-1; // 끝점을 중앙값 이전으로 지정
	}
	
    return end+1;
}